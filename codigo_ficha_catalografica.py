# -*- coding: utf-8 -*-
"""CODIGO_ficha_catalografica

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1z_8oSO493TA18rBKZXE6FPIEFE3luyih
"""

# prompt: excluir todos os arquivos gerados pelo processamento do meu codigo

import os
import shutil

# Define a pasta a ser exclu√≠da
pasta_saida = "fichas_final_com_tabelas"
caminho_zip = "fichas_tabelas_corrigidas.zip"

# Exclui a pasta e seu conte√∫do
if os.path.exists(pasta_saida):
    shutil.rmtree(pasta_saida)
    print(f"Pasta '{pasta_saida}' e seu conte√∫do foram exclu√≠dos com sucesso.")
else:
    print(f"Pasta '{pasta_saida}' n√£o existe.")

# Exclui o arquivo zip
if os.path.exists(caminho_zip):
    os.remove(caminho_zip)
    print(f"Arquivo '{caminho_zip}' foi exclu√≠do com sucesso.")
else:
    print(f"Arquivo '{caminho_zip}' n√£o existe.")

"""_____________________________"""

!pip install pandas openpyxl python-docx  # Instala√ß√£o (somente para Google Colab)

import pandas as pd  # Trabalha com planilhas (Excel)
from docx import Document  # Manipula arquivos Word (.docx)
import os  # Lida com arquivos e pastas
import zipfile  # Cria arquivos compactados (.zip)
import re  # Manipula textos e express√µes regulares

# Caminhos dos arquivos de entrada e sa√≠da
caminho_planilha = "/content/BASE_DE_FICHAS_PARA_AUTOMA√á√ÉO (3).xlsx"  # Planilha de dados
caminho_template_ficha = "/content/Modelo_WBA0048_v3_Lideran√ßa_FC teste.docx"  # Modelo da ficha
caminho_template_modelo = "/content/Modelo_WBA0048_v3_Lideran√ßa (2).docx"  # Modelo da folha de rosto
pasta_saida = "fichas_final_com_tabelas"  # Pasta onde ser√£o salvos os arquivos gerados

os.makedirs(pasta_saida, exist_ok=True)  # Cria a pasta, se n√£o existir

# Fun√ß√£o para formatar o nome do autor no estilo "Sobrenome, Nome"
def formatar_autor(nome):
    if pd.isna(nome) or not str(nome).strip():  # Se estiver vazio ou NaN, retorna vazio
        return ""
    partes = nome.strip().split()  # Divide o nome por espa√ßos
    if len(partes) < 2:  # Se tiver s√≥ um nome, retorna ele mesmo
        return nome.strip()
    sobrenome = partes[-1]  # √öltima parte como sobrenome
    restante = " ".join(partes[:-1])  # Demais como nome
    return f"{sobrenome}, {restante}"  # Formato final

# Fun√ß√£o para limpar nomes de arquivos, evitando caracteres inv√°lidos
def limpar_nome_arquivo(texto):
    if pd.isna(texto) or str(texto).lower() == 'nan' or not str(texto).strip():  # Se vazio ou 'nan'
        return 'SemNome'
    texto = str(texto).replace(":", "")  # Remove dois-pontos
    texto = re.sub(r'[\\/*?"<>|]', "", texto)  # Remove caracteres proibidos
    return texto.strip() or 'SemNome'  # Retorna texto limpo ou 'SemNome'

# Fun√ß√£o para deixar a primeira letra da palavra-chave mai√∫scula
def formatar_palavrachave(texto):
    if pd.isna(texto) or not str(texto).strip():  # Se vazio, retorna vazio
        return ""
    return str(texto).strip().capitalize()

# Carrega a planilha de dados
try:
    df = pd.read_excel(caminho_planilha)  # L√™ a planilha Excel
    df.fillna('', inplace=True)  # Substitui NaN por string vazia
    df['AUTOR_FORMATADO'] = df['AUTOR1'].apply(formatar_autor)  # Cria coluna com autor formatado
except Exception as e:
    print("‚ùå Erro ao carregar a planilha.")
    print(f"Detalhes: {e}")
    raise e  # Para a execu√ß√£o se der erro

# Fun√ß√£o que substitui placeholders nos par√°grafos do Word
def substituir_em_paragrafo(par, dados):
    if not par.text.strip():  # Se o par√°grafo estiver vazio, n√£o faz nada
        return
    novo_texto = par.text
    for chave, valor in dados.items():  # Substitui cada placeholder pelo valor correspondente
        novo_texto = novo_texto.replace(chave, str(valor) if pd.notna(valor) else "")
    if not dados.get('<SUBTITULO>'):  # Remove se n√£o tiver subt√≠tulo
        novo_texto = re.sub(r':\s*<SUBTITULO>', '', novo_texto)
    if not dados.get('<VOLUME>'):  # Remove se n√£o tiver volume
        novo_texto = re.sub(r':\s*v\.\s*<VOLUME>', '', novo_texto)
    if novo_texto != par.text:
        for i in range(len(par.runs)):  # Limpa fragmentos do par√°grafo
            par.runs[i].text = ""
        par.text = novo_texto  # Atualiza o texto do par√°grafo

# Fun√ß√£o para aplicar substitui√ß√µes em todo o documento Word
def substituir_placeholders(doc, dados):
    for par in doc.paragraphs:
        substituir_em_paragrafo(par, dados)  # Substitui nos par√°grafos principais
    for tabela in doc.tables:
        for linha in tabela.rows:
            for celula in linha.cells:
                for par in celula.paragraphs:
                    substituir_em_paragrafo(par, dados)  # Substitui nas tabelas

# Cria ou limpa o arquivo de log de erros
with open("erros_log.txt", "w") as log:
    log.write("LOG DE ERROS - GERA√á√ÉO DE FICHAS\n\n")

# Loop que percorre cada linha da planilha
for i, linha in df.iterrows():
    if not str(linha.get('AUTOR1', '')).strip():  # Se n√£o tiver autor, pula
        continue

    try:
        # Formata volume, se houver
        volume_formatado = ""
        if str(linha.get('VOLUME', '')).strip():
            try:
                volume_formatado = f": v. {int(float(linha['VOLUME']))}"  # Converte para inteiro
            except:
                volume_formatado = ""

        # Formata t√≠tulo e subt√≠tulo
        titulo_valor = str(linha.get('TITULO', '')).strip()
        subtitulo_valor = str(linha.get('SUBTITULO', '')).strip()
        if not subtitulo_valor and titulo_valor.endswith(":"):  # Remove ':' se n√£o houver subt√≠tulo
            titulo_valor = titulo_valor[:-1].strip()
        subtitulo_formatado = f": {subtitulo_valor}" if subtitulo_valor else ""

        # Formata palavras-chave
        palavrachave1 = formatar_palavrachave(linha.get('PALAVRACHAVE1', ''))
        palavrachave2 = formatar_palavrachave(linha.get('PALAVRACHAVE2', ''))
        palavrachave3 = formatar_palavrachave(linha.get('PALAVRACHAVE3', ''))

        # Prepara dados para substituir no Word
        substituicoes = {
            "<COORDENADOR>": linha.get('COORDENADOR', ''),
            "<REVISOR>": linha.get('REVISOR', ''),
            "<AUTOR>": linha['AUTOR_FORMATADO'],
            "<AUTOR1>": linha.get('AUTOR1', ''),
            "<AUTOR2>": linha.get('AUTOR2', ''),
            "<AUTOR3>": linha.get('AUTOR3', ''),
            "<CUTTER>": linha.get('CUTTER', ''),
            "<TITULO>": titulo_valor,
            "<SUBTITULO>": subtitulo_formatado,
            "<PAGINA>": str(int(float(linha['PAGINA']))) if str(linha.get('PAGINA', '')).strip() else '',  # P√°gina como n√∫mero inteiro
            "<ISBN>": linha.get('ISBN', ''),
            "<PALAVRACHAVE1>": palavrachave1,
            "<PALAVRACHAVE2>": palavrachave2,
            "<PALAVRACHAVE3>": palavrachave3,
            "<CDD>": linha.get('CDD', ''),
            "<VOLUME>": volume_formatado,
            "<NOME1>": linha['AUTOR_FORMATADO']
        }

        # Define nome da pasta onde os arquivos ser√£o salvos
        autor_nome = limpar_nome_arquivo(linha['AUTOR_FORMATADO'])
        titulo_nome = limpar_nome_arquivo(titulo_valor)
        nome_pasta = f"{autor_nome} - {titulo_nome}"
        caminho_pasta = os.path.join(pasta_saida, nome_pasta)
        os.makedirs(caminho_pasta, exist_ok=True)  # Cria a pasta, se n√£o existir

        # Gera a ficha catalogr√°fica
        doc_ficha = Document(caminho_template_ficha)
        substituir_placeholders(doc_ficha, substituicoes)
        doc_ficha.save(os.path.join(caminho_pasta, "Ficha Catalogr√°fica.docx"))

        # Gera o modelo preenchido
        doc_modelo = Document(caminho_template_modelo)
        substituir_placeholders(doc_modelo, substituicoes)
        doc_modelo.save(os.path.join(caminho_pasta, "Modelo Preenchido.docx"))

        print(f"‚úÖ Ficha gerada com sucesso: {nome_pasta}")  # Mostra sucesso

    except Exception as e:
        print(f"‚ùå Erro ao processar linha {i+1} - {linha.get('TITULO', 'Sem T√≠tulo')}")  # Mostra erro
        print(f"    ‚û§ Detalhes: {e}")
        with open("erros_log.txt", "a") as log:  # Registra erro no log
            log.write(f"Linha {i+1} - {linha.get('TITULO', 'Sem T√≠tulo')}\n")
            log.write(f"Erro: {str(e)}\n\n")

# Compacta todos os arquivos criados em um .zip
try:
    caminho_zip = "fichas_e_modelos.zip"
    with zipfile.ZipFile(caminho_zip, 'w') as zipf:
        for raiz, _, arquivos in os.walk(pasta_saida):  # Percorre a pasta
            for arquivo in arquivos:
                caminho_completo = os.path.join(raiz, arquivo)
                caminho_relativo = os.path.relpath(caminho_completo, pasta_saida)
                zipf.write(caminho_completo, caminho_relativo)  # Adiciona ao zip
    print(f"üì¶ Arquivo compactado com sucesso: {caminho_zip}")  # Mostra sucesso
except Exception as e:
    print("‚ùå Erro ao criar o arquivo ZIP.")  # Mostra erro
    print(f"Detalhes: {e}")
    with open("erros_log.txt", "a") as log:  # Registra erro no log
        log.write(f"Erro ao criar o ZIP: {str(e)}\n")

print("üöÄ Processo finalizado.")  # Indica que terminou tudo